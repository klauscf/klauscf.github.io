力扣前31-40题相对可以的答案解析，自己刷题打卡，欢迎大家一起讨论，

不过博客还未开通评论功能待后续开发。

## [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

难度中等842

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

### 代码思路

从右往左找，找到第一个右边比左边的数，再在右边从右往左找，找到一个刚好大于他的数，找完之后交换，从交换完左边数（这个数不算）开始数起，是一个逆序数组，旋转后从小到大

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if(nums.size()==0 || nums.size()==1) return ;
        int i=nums.size()-2,j=nums.size()-1;
        for(;i>=0;i--){
            if(nums[i]<nums[i+1])
                break;
        }
        ///while(i>=0 && nums[i]>= nums[i+1]) i--;

        for(;j>=0,i>=0;j--)
        {
            if(nums[j]>nums[i]){
                swap(nums[i],nums[j]);
                break;
            }
        }
        reverse(nums.begin()+1+i,nums.end());
    }
};
```

## [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

难度困难1070

给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

### 代码思路

这个题是字串问题，还不能简单的参考有效括号那一题，主要是这2个“()(()"和”()(())",一个是2，一个是6，还是有差别的，最后参照了一下官方的答案

```
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxRes = 0;
        if(s.size()==0) return maxRes;
        stack<int> taken;
        taken.push(-1);
        
        for(int i=0;i<s.size();i++)
        {
            if(s[i] == ')'){
                taken.pop();
                if(!taken.empty())
                    maxRes=max(maxRes,i-taken.top());
                else{
                    taken.push(i);
                }
            }
            else
                taken.push(i);
        }
        return maxRes;
    }
};
```

## [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

难度中等1072

给你一个整数数组 `nums` ，和一个整数 `target` 。

该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。（例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` ）。

请你在数组中搜索 `target` ，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

 

**提示：**

- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 中的每个值都 **独一无二**
- `nums` 肯定会在某个点上旋转
- `-10^4 <= target <= 10^4`

### 代码思路

这个题对数级别的复杂度只能用二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if(n==0 || n==1 && nums[0] != target) return -1;

        int l=0,r=n-1;
        while(l<=r)
        {
            int mid =(l+r)/2;
            if(target == nums[mid]){
                return mid;
            }
                
            if(nums[0]<=nums[mid]){
                if(target>=nums[0] && target<nums[mid])
                    r = mid-1;
                else
                    l = mid +1;//类似递归的这种想法吧
            }else{
                if(target<=nums[n-1] && target>nums[mid])
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return -1;
    }
};
```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

难度中等665

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

如果数组中不存在目标值，返回 `[-1, -1]`。

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

### 代码思路

代码思路刚刚上手写了个很复杂的，感觉不对的亚子，感觉搜索这里可以减短事件

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        if(n==0||n==1 && nums[0]!=target) return {-1,-1};

        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = (l+r)/2;
            if(target==nums[mid]){
                int begin=mid,end=mid;
                while(begin>0 && nums[begin]==target && nums[begin-1]==target)
                    begin--;
                while(end<n-1 && nums[end] == target && nums[end+1]==target)
                    end++;
                return {begin,end};
            }else if(target<nums[mid]){
                r = mid - 1;
            }else{
                l = mid + 1;
            }
        }
        return {-1,-1};
    }
};
```

参照了一下大佬们的巧妙写法，尤其是找左右界的，其实也可以直接写2次二分

```c++
class Solution {
public:
    int searchOneSide(vector<int>& nums, int target,bool left){
        int l=0,r=nums.size();
        while(l<r){
            int mid = (l+r)>>1;
            if(target < nums[mid] ||(left && target == nums[mid]))
                r = mid;
            else
                l = mid + 1;
        }
        return l;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.empty()) return {-1,-1};
        int left = searchOneSide(nums,target,true);
        if(left == nums.size() || target != nums[left])
            return {-1,-1};
        int right = searchOneSide(nums,target,false)-1;
        return{left,right};
    }
};
```

## [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

难度简单741

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

### 代码思路

不含重复的那就是相当于找最左边界的，和上面那一道题有点像

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {

        int l=0,r=nums.size()-1;

        while(l<=r)
        {
            int mid = (l+r)/2;
            if(target == nums[mid])
                return mid;
            else if(target<nums[mid])
                r = mid - 1;
            else
                l = mid + 1;
        }
        return l;
    }
};
```



## [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

难度中等445

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![img](../images/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1:**

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。

### 代码思路

本来用set写，发现了一个很简单的写法，copy了一下

```c++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int col[9][10]={0}, row[9][10]={0},box[9][10]={0};//10对应0-9

        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[i].size();j++)
            {
                if(board[i][j] == '.') continue;
                int curNum = board[i][j] - '0';
                if(col[i][curNum]) return false;
                if(row[j][curNum]) return false;
                if(box[(i/3)*3+j/3][curNum]) return false; //3* 是将9块分成 0 1 2;3 4 5;6 7 8

                col[i][curNum] = 1;
                row[j][curNum] = 1;
                box[(i/3)*3 + j/3][curNum] = 1;
            }
        }
            
        return true;
    }
};
```

