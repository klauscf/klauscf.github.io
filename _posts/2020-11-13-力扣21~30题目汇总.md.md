力扣前21-30题相对可以的答案解析，自己刷题打卡，欢迎大家一起讨论，

不过博客还未开通评论功能待后续开发。



## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

难度简单1375

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```



### 代码思路

很直观，每次比较一下就行

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* root = new ListNode(0);
        ListNode* cur = root;
        while(l1 && l2)
        {
            if(l1->val <= l2->val){
                cur->next = new ListNode(l1->val);
                cur = cur->next;
                if(l1) l1=l1->next;
            }else{
                cur->next = new ListNode(l2->val);
                if(l2) l2=l2->next;
                cur = cur->next;
            }
        }
        if(l1) cur->next=l1;
        if(l2) cur->next=l2;
        
        return root->next;
    }
};
```



## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

难度中等1411

数字 *n* 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例：**

```
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```

### 代码思路

我瞄了一眼别人的，尝试写了一下反向回溯

```c++
class Solution {
public:
    vector<string> res;
    void dfs(int l,int r,string tmp)
    {
        if(l==0 && r==0){
            res.push_back(tmp);
            return ;
        }
        if(l>0){
            tmp.push_back('(');
            dfs(l-1,r,tmp);
            tmp.pop_back();
        }
        if(r>l){
            tmp.push_back(')');
            dfs(l,r-1,tmp);
            tmp.pop_back();
        }
    }
    vector<string> generateParenthesis(int n) {
        if(n<=0) return res;
        string vaild = "";
        dfs(n,n,vaild);
        return res;
    }
};
```

正向回溯好像执行事件和内存比反向的高一些

```c++
class Solution {
public:
    vector<string> res;
    void dfs(int l,int r,string &tmp,int n)
    {
        if(l==n && r==n){
            res.push_back(tmp);
            return ;
        }
        if(l<n){
            tmp.push_back('(');
            dfs(l+1,r,tmp,n);
            tmp.pop_back();
        }
        if(r<l){ //有右括号可用
            tmp.push_back(')');
            dfs(l,r+1,tmp,n);
            tmp.pop_back();
        }
    }
    vector<string> generateParenthesis(int n) {
        if(n<=0) return res;
        string vaild = "";
        dfs(0,0,vaild,n);
        return res;
    }
};
```

## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

难度困难991

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

 

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

### 代码思路

这个题刚刚开始还有点难做，后来试了一下，感觉还行，直接用优先队列存值是没问题的，只是内存比较大，排序好的更建议用二分第一种

```c++
/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode() : val(0), next(nullptr) {}
*     ListNode(int x) : val(x), next(nullptr) {}
*     ListNode(int x, ListNode *next) : val(x), next(next) {}
* };
*/
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* root = new ListNode(0);
        ListNode* cur = root;

        priority_queue<int, vector<int>, greater<int>> q;
        for(auto x:lists)
            while(x) q.push(x->val),x=x->next;

        while(q.size()){
            ListNode* top = new ListNode(q.top());
            q.pop();
            cur->next = top;
            cur = cur->next;
            //if(top->next) q.push(top->next);
        }
        return root->next;
    }
};
```

第二种就是自己写一个符合自己要求的优先队列，方式有几个

方式1：

```c++
class Solution {
public:
    struct cmp{
        bool operator()(ListNode* l1,ListNode* l2){
            return l1->val > l2->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* root = new ListNode(0);
        ListNode* cur = root;

        priority_queue<ListNode*, vector<ListNode*>, cmp> q;
        for(auto x : lists) if(x) q.push(x);

        while(!q.empty()){
            ListNode* top = q.top();
            q.pop();
            cur->next = top;
            cur = cur->next;
            if(top && top->next) q.push(top->next);
        }
        return root->next;
    }
};
```

方式二：

```c++
class Solution {
public:
    struct Status {
        int val;
        ListNode *ptr;
        bool operator < (const Status &rhs) const {
            return val > rhs.val;
        }
    };

    priority_queue <Status> q;
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for (auto node: lists) {
            if (node) q.push({node->val, node});
        }
        ListNode head, *tail = &head;
        while (!q.empty()) {
            auto f = q.top(); q.pop();
            tail->next = f.ptr;
            tail = tail->next;
            if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});
        }
        return head.next;
    }
};
```

我更倾向方式二，方便理解。